
## Структура
- Файл `cef.asi` должен находится в корневой папке с игрой (собирается как `loader.dll`).
- Папка `cef` со всем содержимым так же там же.
- Так же создается папка `CEF` по пути `Мои документы/GTA San Andreas User Files/CEF/`, где хранится кэш, куки файлы и прочие вещи, необходимые для корректной работы Chromium.
- `gta_sa.exe`
- `cef.asi`
- `cef/`
    - `client.dll`
    - `libcef.dll`
    - `renderer.exe`
    - etc …


## Советы по использованию и некоторые ограничения
- В идеале иметь один браузер со всеми интерфейсами. Не создавать новые для разных действий, а использовать встроенную систему событий.
- Если имеются клиентские плагины, которые используют относительные пути, то, скорее всего, они поломаются и будут неверно работать. К сожалению, на данный момент во время инициализации меняется текущая директория в другом потоке. Как пример: CLEO библиотека может создать свой лог `cleo.log`, а так же папки `cleo_text` и `cleo_saves` в папке `cef`. Для корректной работы следует лучше узнавать путь до текущего исполняемого файла (`gta_sa.exe`).

## Pawn API

`cef_create_browser(player_id, browser_id, const url[], hidden, focused)`

Создает браузер для указанного игрока.

`cef_destroy_browser(player_id, browser_id)`

Удаляет браузер.

`cef_hide_browser(player_id, browser_id, hide)`

Скрывает браузер.

`cef_emit_event(player_id, const event_name[], args…)`

Вызвать событие у клиента. Поддерживаемые типы аргументов: `string`, `integer`, `float`.

`cef_subscribe(const event_name[], const callback[])`

Подписаться на событие от клиента. Сигнатура функции колбека: `Callback(player_id, const arguments[])`

`cef_player_has_plugin(player_id)`

Проверка на наличие плагина у клиента.

`cef_create_ext_browser(player_id, browser_id, const texture[], const url[], scale)`

Создает браузер как и в первом случае, но с пометкой, что он будет отображаться на объектах на определенной текстуре. Параметр `scale` указывает во сколько раз нужно увеличить стандартную текстуру. Например, если стандартная текстура имеет размер `250x30` будет иметь размер `1250x150` при переданном параметре в 5 единиц.

`cef_append_to_object(player_id, browser_id, object_id)`

Заменяет текстуру переданного объекта на изображение браузера у клиента. Браузер должен быть создан с помощью `cef_create_ext_browser`, а так же должна присутствовать текстура, указанная при создании, для корректного отображения.

`cef_remove_from_object(player_id, browser_id, object_id)`

Возвращает оригинальную текстуру объекта.

`cef_toggle_dev_tools(player_id, browser_id, enabled)`

Включает / выключает инструменты разработчика.

`native cef_set_audio_settings(player_id, browser_id, Float:max_distance, Float:reference_distance)`

Выставляет максимальную слышемую дистанцию для браузера на объекте. `reference_distance` - расстояние, до которого будет максимальная громкость, а после пойдет на понижение от `max_distance` до 0.

`cef_focus_browser(player_id, browser_id, focused)`

Функция делает браузер сфокусированным. Выводится на первый план, получает все события с клавиатуры и мыши. То же самое, что и передача аргумента `focused = true` при создании браузера.

`cef_always_listen_keys(player_id, browser_id, listen)`

Позволяет браузеру получать ввод с клавиатуры в фоне, даже если браузер не имеет фокуса или скрыт. Это позволяет использовать в JS коде функции для подписки на события от клавиатуры все время. Например, можно сделать открытие / закрытие интерфейса по нажатию клавиши (`window.addEventListener("keyup")`).

`cef_load_url(player_id, browser_id, const url[])`

Загружает указанный URL у заданного браузера. Быстрее, чем пересоздание браузера.


### Так же есть два события встроенных в плагин:

`forward OnCefBrowserCreated(player_id, browser_id, status_code)`
Вызывается, когда клиент создал у себя браузер по запросу от сервера / плагина. Значение `status_code` либо 0 (при неудачном создании), либо HTTP код (200, 404 etc).

`forward OnCefInitialize(player_id, success)`
Вызывается после подключения клиента к CEF серверу, либо по истечению тайм-аута. Грубо говоря, замена ручной проверки `cef_player_has_plugin`.

## Browser API

Так же у браузеров есть свое API для управления ими.
`cef.set_focus(focused)`

Фокусируется на браузере, что позволяет ему быть поверх всех остальных окон, а так же иметь возможность вводить с клавиатуры и мыши в него.

`cef.on(event_name, callback)`
Подписывается на событие от браузера / других плагинов.

`cef.off(event_name, callback)`
СЛОМАНА НА ДАННЫЙ МОМЕНТ
Отписывается от события. Чтобы использовать данную функцию, необходимо передавать переменную, которая содержит функцию на колбек события, указанный при подписке на событие.

`cef.hide(hide)`
Скрывает браузер и отключает звук от него.

`cef.emit(event_name, args…)`
Вызвать событие на сервере / в сторонних плагинах с указанными аргументами. Поддерживает все типы, кроме объектов с полями и функций. Замечание: в плагинах возможно использовать все типы по человечески, но на сервере все аргументы преобразуются в единую строку, разделенную пробелами.

## C API

не работает, сорри

рабочий пример в `cef-interface`, а так же API в `cef-api` и `client/external.rs`

```C++
    #include <cstdint>
    
    // Отменить продолжение выполнения колбеков события. А так же не отправлять его серверу.
    static const int EXTERNAL_BREAK = 1;
    // Продолжить выполнение. Если никто не отменил его, будет передано серверу.
    static const int EXTERNAL_CONTINUE = 0;
    
    using BrowserReadyCallback = void(*)(uint32_t);
    using EventCallback = int(*)(const char*, cef_list_value_t*);
    
    extern "C" {
        // Проверка на существование браузера в игре.
        bool cef_browser_exists(uint32_t browser);
        // Создан ли браузер и загружен веб-сайт.
        bool cef_browser_ready(uint32_t browser);
        // Создать браузер с указанными параметрами. Эта функция асинхронная, браузер создается не сразу.
        void cef_create_browser(uint32_t id, const char *url, bool hidden, bool focused);
        // Создать CefListValue внутри клиента.
        cef_list_value_t *cef_create_list();
        // Удалить браузер у клиента.
        void cef_destroy_browser(uint32_t id);
        // Вызвать событие у браузера.
        void cef_emit_event(const char *event, cef_list_value_t *list);
        // Сфокусировать ввод на браузере, а так же вывести его поверх всех остальных.
        void cef_focus_browser(uint32_t id, bool focus);
        // Активно ли окно игры.
        bool cef_gta_window_active();
        // Скрыть браузер.
        void cef_hide_browser(uint32_t id, bool hide);
        // Проверить доступен ли ввод для конкретного браузера.
        bool cef_input_available(uint32_t browser);
        // Подписаться на событие полного создания браузера.
        void cef_on_browser_ready(uint32_t browser, BrowserReadyCallback callback);
        bool cef_ready();
        // Подписаться на события от браузера.
        void cef_subscribe(const char *event, EventCallback callback);
        // Попытаться сфокусироваться на браузере. Аналогично паре `cef_input_available` + `cef_focus_browser`,
        // но с одним значительным условием, между выполнением этих двух функции кто-то другой может захватить фокус.
        // А данная функция атомарна, что позволяет проверить и сразу же захватить, гарантируя,
        // что никто другой не сможет в это время получить фокус.
        bool cef_try_focus_browser(uint32_t browser);
    }
```


## Инструкция к применению

### Описание
Браузер можно создать из двух мест: из игрового мода и плагинов.


Браузер имеет два дополнительных состояния: `hidden` и `focused`. Первое состояние отвечает за отображение браузера на экране игрока. Второе состояние сложнее: если браузер сфокусирован (`focused = true`), то у игрока замораживается камера, появляется курсор и весь его ввод (от клавиатуры и мыши) идет прямиком в браузер, минуя GTA и SA:MP (за исключением некоторых функций по типу скриншота на F8). Игрок самостоятельно никогда не сможет выйти из этого состояния, вы должны поспособствовать этому в коде интерфейса браузера. Например, можно слушать нажатие клавиши ESC и при ее нажатии вызывать `cef.set_focus(false)`.


Условно говоря, что открыв какой-нибудь youtube.com из него уже никогда не выйти, не закрыв игру или не поставив таймер на удаление браузера в моде.


Эти два состояния полностью независимы друг от друга, то есть браузер может быть `hidden = false`, но в тот же момент `focused = false`, в таком случае браузер будет показан, но доступа к вводу у него не будет, а игрок может спокойно совершать действия в игре.


Взаимодействие из игрового мода
В двух словах: игровой мод должен использовать только несколько нативных функций (создание / удаление браузеров, вызов событий в браузере, а так же подписка на них).


Ну и чуть кода: https://gist.github.com/ZOTTCE/5c5bf3b63b1fec29c104e0085cd51f9f


Так же есть небольшой пример псевдокода, показывающий взаимодействие игрового мода, плагина и браузера: https://gist.github.com/ZOTTCE/7dee2d196138457772aa79355069014a
